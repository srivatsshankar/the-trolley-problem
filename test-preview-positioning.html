<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Preview Positioning Verification</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #87CEEB;
            font-family: Arial, sans-serif;
        }

        #gameCanvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 15px;
            border-radius: 5px;
            font-size: 12px;
            z-index: 100;
            max-width: 350px;
        }

        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 15px;
            border-radius: 5px;
            font-size: 14px;
            z-index: 100;
        }

        .button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 8px 16px;
            margin: 2px;
            border-radius: 3px;
            cursor: pointer;
        }

        .button:hover {
            background: #45a049;
        }

        .button.selected {
            background: #FF6B35;
        }

        .verification-info {
            margin-top: 10px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            font-size: 11px;
        }
    </style>
</head>

<body>
    <canvas id="gameCanvas"></canvas>
    <div id="info">
        <div><strong>Preview Positioning Verification</strong></div>
        <div>ðŸ”´ Red lines = Section boundaries (where transitions occur)</div>
        <div>âœ¨ Preview should appear EXACTLY at next red line</div>
        <div>ðŸ’› Yellow â†’ ðŸ§¡ Orange â†’ ðŸŸ¢ Green progression</div>
        <div class="verification-info">
            <div id="position">Position: 0</div>
            <div id="section">Section: 0 (0% through)</div>
            <div id="track">Current Track: 3</div>
            <div id="selected">Selected Track: 3</div>
            <div id="preview">Preview: None</div>
            <div id="nextBoundary">Next Boundary: 62.5</div>
            <div id="previewLocation">Preview Location: N/A</div>
            <div id="verification">âœ… Positioning: Checking...</div>
        </div>
    </div>

    <div id="controls">
        <div><strong>Track Selection</strong></div>
        <button class="button" id="track1" onclick="selectTrack(1)">Track 1</button>
        <button class="button" id="track2" onclick="selectTrack(2)">Track 2</button>
        <button class="button selected" id="track3" onclick="selectTrack(3)">Track 3</button>
        <button class="button" id="track4" onclick="selectTrack(4)">Track 4</button>
        <button class="button" id="track5" onclick="selectTrack(5)">Track 5</button>
        <div style="margin-top: 10px;">
            <button class="button" onclick="toggleMovement()">Start/Stop</button>
            <button class="button" onclick="resetTrolley()">Reset</button>
            <button class="button" onclick="jumpToSection(0)">Section 0</button>
            <button class="button" onclick="jumpToSection(1)">Section 1</button>
            <button class="button" onclick="jumpToSection(2)">Section 2</button>
            <button class="button" onclick="testTransition()">Test Transition</button>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { TrackGenerator } from './src/systems/TrackGenerator.js';
        import { TrolleyController } from './src/systems/TrolleyController.js';
        import { InputManager } from './src/systems/InputManager.js';
        import { DEFAULT_CONFIG } from './src/models/GameConfig.js';

        console.log('Preview Positioning Verification - Starting...');

        // Get elements
        const canvas = document.getElementById('gameCanvas');
        const positionDiv = document.getElementById('position');
        const sectionDiv = document.getElementById('section');
        const trackDiv = document.getElementById('track');
        const selectedDiv = document.getElementById('selected');
        const previewDiv = document.getElementById('preview');
        const nextBoundaryDiv = document.getElementById('nextBoundary');
        const previewLocationDiv = document.getElementById('previewLocation');
        const verificationDiv = document.getElementById('verification');

        // Three.js setup
        let scene, camera, renderer, trackGenerator, trolleyController, inputManager;
        let trolleySpeed = 6;
        let frameCount = 0;
        let isMoving = false;

        // Visual markers for verification
        let boundaryMarkers = [];

        function initializeThreeJS() {
            console.log('Initializing Three.js...');

            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);

            // Create perspective camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 20, -15);

            // Create renderer
            renderer = new THREE.WebGLRenderer({
                canvas: canvas,
                antialias: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            // Add lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 20, 10);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            console.log('Three.js initialized successfully!');
        }

        function initializeGame() {
            console.log('Initializing positioning verification test...');

            // Create ground
            const groundGeometry = new THREE.PlaneGeometry(400, 100);
            const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x90EE90 });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            // Initialize track generator
            trackGenerator = new TrackGenerator(scene, DEFAULT_CONFIG);
            trackGenerator.initialize();

            console.log('Railway portion length:', DEFAULT_CONFIG.tracks.segmentLength);
            console.log('Game section length:', trackGenerator.getSectionLength());

            // Initialize trolley controller
            trolleyController = new TrolleyController(DEFAULT_CONFIG);
            trolleyController.createTrolley();
            trolleyController.setPosition(new THREE.Vector3(0, 0.75, -50));
            
            // Add trolley to scene
            const trolleyGroup = trolleyController.getTrolleyGroup();
            if (trolleyGroup) {
                scene.add(trolleyGroup);
            }

            // Initialize input manager with enhanced preview system
            inputManager = new InputManager(scene, trolleyController, trackGenerator, DEFAULT_CONFIG);
            inputManager.mount();

            // Create visual markers for section boundaries
            createBoundaryMarkers();

            console.log('Positioning verification test initialized!');
        }

        function createBoundaryMarkers() {
            const sectionLength = trackGenerator.getSectionLength();
            
            // Create markers for first few section boundaries
            for (let i = 0; i <= 5; i++) {
                const boundaryZ = i * sectionLength;
                
                // Create a tall blue marker at each boundary
                const markerGeometry = new THREE.BoxGeometry(0.5, 8, 0.5);
                const markerMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x0066FF,
                    transparent: true,
                    opacity: 0.8
                });
                const marker = new THREE.Mesh(markerGeometry, markerMaterial);
                marker.position.set(0, 4, boundaryZ);
                scene.add(marker);
                boundaryMarkers.push(marker);
                
                console.log(`Created boundary marker at Z=${boundaryZ}`);
            }
        }

        function getCurrentSectionIndex(position) {
            return trackGenerator.getCurrentSectionIndex(position);
        }

        function getSectionProgress(position) {
            return trackGenerator.getSectionProgress(position);
        }

        function verifyPreviewPositioning() {
            if (!inputManager || !trolleyController || !trackGenerator) return;
            
            const position = trolleyController.position;
            const currentSection = getCurrentSectionIndex(position);
            const sectionLength = trackGenerator.getSectionLength();
            const nextBoundaryZ = (currentSection + 1) * sectionLength;
            const currentPreview = inputManager.getCurrentPreview();
            
            let verificationStatus = 'âœ… No preview needed';
            let previewLocationText = 'N/A';
            
            if (currentPreview && currentPreview.mesh) {
                // Get preview curve information
                const userData = currentPreview.mesh.userData;
                const creationSpeed = userData?.creationSpeed || 'unknown';
                const currentSpeed = Math.max(trolleyController.speed, trolleyController.baseSpeed);
                
                previewLocationText = `Boundary=${nextBoundaryZ.toFixed(1)}, Speed=${creationSpeed.toFixed(1)}`;
                
                // Check if preview matches current trolley parameters
                const speedMatch = Math.abs(currentSpeed - creationSpeed) < 0.1;
                const trackMatch = userData?.trackTransition === `${trolleyController.currentTrack}->${inputManager.getSelectedTrack()}`;
                
                if (speedMatch && trackMatch) {
                    verificationStatus = 'âœ… Preview matches trolley parameters';
                } else if (!speedMatch) {
                    verificationStatus = `âš ï¸ Speed mismatch (preview: ${creationSpeed.toFixed(1)}, current: ${currentSpeed.toFixed(1)})`;
                } else if (!trackMatch) {
                    verificationStatus = `âš ï¸ Track mismatch (${userData?.trackTransition} vs ${trolleyController.currentTrack}->${inputManager.getSelectedTrack()})`;
                }
            }
            
            previewLocationDiv.textContent = `Preview: ${previewLocationText}`;
            verificationDiv.textContent = verificationStatus;
        }

        function updateUI() {
            if (trolleyController && trackGenerator && inputManager) {
                const position = trolleyController.position;
                const z = position.z;
                const sectionIndex = getCurrentSectionIndex(position);
                const sectionProgress = (getSectionProgress(position) * 100).toFixed(1);
                const sectionLength = trackGenerator.getSectionLength();
                const currentTrack = trolleyController.currentTrack;
                const selectedTrack = inputManager.getSelectedTrack();
                const currentPreview = inputManager.getCurrentPreview();
                
                positionDiv.textContent = `Position: ${z.toFixed(1)}`;
                sectionDiv.textContent = `Section: ${sectionIndex} (${sectionProgress}% through)`;
                trackDiv.textContent = `Current Track: ${currentTrack}`;
                selectedDiv.textContent = `Selected Track: ${selectedTrack}`;
                
                // Enhanced preview status with color information
                let previewStatus = 'None';
                if (currentPreview) {
                    const progress = getSectionProgress(position);
                    if (progress < 0.5) {
                        previewStatus = 'ðŸ’› Yellow (First 50%)';
                    } else {
                        previewStatus = 'ðŸ§¡ Orange (Final 50%)';
                    }
                }
                previewDiv.textContent = `Preview: ${previewStatus}`;
                
                // Show next section boundary where transition will occur
                const nextBoundaryZ = ((sectionIndex + 1) * sectionLength).toFixed(1);
                nextBoundaryDiv.textContent = `Next Boundary: ${nextBoundaryZ}`;
                
                // Verify preview positioning
                verifyPreviewPositioning();
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            frameCount++;

            // Move trolley if enabled
            if (isMoving && trolleyController) {
                const deltaTime = 0.016; // Approximate 60fps
                const currentPos = trolleyController.position;
                trolleyController.setPosition(new THREE.Vector3(currentPos.x, currentPos.y, currentPos.z + trolleySpeed * deltaTime));

                // Update trolley controller
                trolleyController.update(deltaTime);

                // Update track generation
                if (trackGenerator) {
                    trackGenerator.updateGeneration(trolleyController.position);
                }

                // Update input manager (handles enhanced preview system)
                if (inputManager) {
                    inputManager.update(deltaTime);
                }

                // Update camera to follow trolley
                const targetCameraZ = trolleyController.position.z - 15;
                camera.position.z += (targetCameraZ - camera.position.z) * 0.05;
                camera.lookAt(trolleyController.position.x, 0, trolleyController.position.z + 15);

                // Reset when too far
                if (trolleyController.position.z > 400) {
                    resetTrolley();
                }
            }

            // Update UI every 10 frames
            if (frameCount % 10 === 0) {
                updateUI();
            }

            if (renderer && scene && camera) {
                renderer.render(scene, camera);
            }
        }

        // Global functions for buttons
        window.selectTrack = function(trackNumber) {
            if (inputManager) {
                inputManager.selectTrack(trackNumber);
            }
            
            // Update button styles
            document.querySelectorAll('.button').forEach(btn => btn.classList.remove('selected'));
            document.getElementById(`track${trackNumber}`).classList.add('selected');
            
            console.log(`Selected track ${trackNumber}`);
        };

        window.toggleMovement = function() {
            isMoving = !isMoving;
            console.log('Movement:', isMoving ? 'STARTED' : 'STOPPED');
        };

        window.resetTrolley = function() {
            if (trolleyController && inputManager) {
                trolleyController.setPosition(new THREE.Vector3(0, 0.75, -50));
                inputManager.reset();
                
                // Reset UI
                document.querySelectorAll('.button').forEach(btn => btn.classList.remove('selected'));
                document.getElementById('track3').classList.add('selected');
                
                console.log('Trolley reset');
            }
        };

        window.jumpToSection = function(sectionIndex) {
            if (trolleyController && trackGenerator) {
                const sectionLength = trackGenerator.getSectionLength();
                const sectionStartZ = sectionIndex * sectionLength + 5; // 5 units into the section
                trolleyController.setPosition(new THREE.Vector3(0, 0.75, sectionStartZ));
                console.log(`Jumped to section ${sectionIndex} at Z=${sectionStartZ}`);
            }
        };

        window.testTransition = function() {
            if (trolleyController && trackGenerator && inputManager) {
                // Jump to just before a section boundary
                const sectionLength = trackGenerator.getSectionLength();
                const boundaryZ = sectionLength; // First section boundary
                const testZ = boundaryZ - 2; // 2 units before boundary
                
                trolleyController.setPosition(new THREE.Vector3(0, 0.75, testZ));
                
                // Select a different track to create preview
                const currentTrack = trolleyController.currentTrack;
                const targetTrack = currentTrack === 3 ? 1 : 5; // Switch to track 1 or 5
                inputManager.selectTrack(targetTrack);
                
                // Update UI to show selected track
                document.querySelectorAll('.button').forEach(btn => btn.classList.remove('selected'));
                document.getElementById(`track${targetTrack}`).classList.add('selected');
                
                console.log(`Test setup: Trolley at Z=${testZ}, switching from track ${currentTrack} to ${targetTrack}`);
                console.log(`Preview should appear at boundary Z=${boundaryZ}`);
            }
        };

        // Handle window resize
        window.addEventListener('resize', () => {
            if (camera && renderer) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
        });

        // Initialize and start
        initializeThreeJS();
        initializeGame();
        animate();
    </script>
</body>

</html>